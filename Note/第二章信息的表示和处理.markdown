# 第二章 信息的表示和处理

研究三种最重要的数字表示：

1. 无符号(unsigned) 编码基于传统的二进制表示法，表示大于或者等于零的数字。
2. 补码(two's-complement) 编码是表示有符号整数的最常见的方式。
3. 浮点数(float-point)编码是表示实数的科学记数法以2为基数的版本。

## 2.1 信息存储

### 2.1.1 十六进制表示法

### 2.1.2 字数据大小

计算机有一个字长 $w$ ,字长决定的最重要的系统参数就是虚拟地址的空间最大大小。

对于一个字长为$w$ 位的机器，虚拟地址的范围为$0\sim2^w-1$ ,程序最多访问$2^w$个字节。

32位字长限制虚拟地址空间为4GB,刚刚超过$4\times 10^9$个字节，扩展到64位字长为16EB，大约是$1.84\times 10^{19}$字节。

大多数64位的机器也可以运行32位机器编译的程序，这是一种向后兼容。(32位与64位程序的区别是在于程序是如何编译的，而不是编译的机器类型)。

C语言支持整数和浮点数多种数据格式。

![img](.\picture\2.1.2-1.PNG)

数据类型long一般在32位程序中为4字节，在64位程序中为8字节。

为了避免不同编译器设置带来的奇怪行为，ISO C99引入了一类数据类型，它的数据大小是固定的，不随编译器和机器设置而变化，如int32_t和int64_t,它们分别为4字节和8字节。

程序员应当使他们的程序在不同的机器和编译器上可移植。在过去的一段时间32位机器和32位程序是主流，使得许多程序的编写都按照上图中32位程序来的，当移植到64位机器上的时候，许多隐藏的对字长的依赖性就会显现出来。比如，假设一个声明int类型的变量来存储一个指针，在32位机器上能正常工作，但是在64位机器中就会出现问题。

### 2.1.3 寻址和字节顺序

对于跨月多字节的程序对象，建立两个规则：这个对象的地址是多少？在内存中如何排布这些字节？

在几乎所有的机器上，对象的地址为所使用的字节中最小的地址。

最低有效位在低地址处为小端法，最高有效位在低地址处为大端法。

假设一个int类型变量x，位于地址0x100处，十六进制值为0x01234567,最低有效位是0x67。

![img](./picture/2.1.3-1.PNG) 

大多数Intel兼容机都只用小端模式。Android和IOS都是只运行小端模式。

对于大多数程序员来说，其机器所使用的字节顺序是完全不可见的。有时候字节顺序会成为问题，一个常见问题是当小端法机器产生的数据被发送到大端法及其时，字节会成为反序的。为了避免这种问题，网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则，以确保发送方机器将它内部表示转化为网络标准，而接收方机器则将网络标准转换为它的内部表示。第二个问题是在阅读表示整数数据的字节序列的时候。第三个问题是在编写规避正常的类型系统的程序时。

### 2.1.4 表示字符串

C语言中字符串被编码为一个以null结尾的字符数组。最常见的编码是ASCII字符码，使用ASCII作为字符码与字节顺序和字大小规则无关，因此文本数据比二进制数据具有更强的平台独立性。

### 2.1.5 表示代码

指令编码是不一样的，不同及其类型使用不同且不兼容的指令和编码方式。

### 2.1.6 布尔代数简介

![img](./picture/2.1.6-1.PNG)

   

可以把布尔运算扩展到位向量的运算，位向量就是固定长度 $w$,由0和1组成的串。假设$a,b$分别表示位向量$[a_{w-1},a_{w-2},\dots,a_0],[b_{w-1},b_{w-2},\dots,b_0]$ ,我们将 $a \And b$ 也定义为长度为$w$的位向量，第$i$个元素为 $a_i\And b_i,0\leq i < w$。

位向量很有用的应用就是表示有限集合，用位向量 $[a_{w-1},a_{w-2},\dots,a_0]$编码任何子集$A\subseteq \{ 0,1,\dots w-1\}$,其中$a_i=1$当且仅当$i \in A$。

### 2.1.7 C语言中的位级运算

运算符 $\And ,| ,\sim ,$ ^  

C语言支持按位布尔运算。

位级运算的常见用法就是实现掩码运算。位级运算$x \And 0xFF$生成一个由x的最低有效字节组成的值，其他位的值就被置为0。

### 2.1.8 C语言中的逻辑运算

运算符 $||,\And\And,!$

逻辑运算符认为所有非0的参数都表示TRUE，参数0表示FALSE。

逻辑运算符和位级运算符一个重要区别是，如果对第一个参数求值就能确定表达式的值，那么逻辑运算符就不会对第二个参数求值.`a && 5/a`不会造成被零除，`p && *p++`也不会到导致间接引用空指针。

### 2.1.9 C语言中的移位运算

C语言中提供了移位运算，向左或者向右移动位模式。移位运算是从左至右结合的，`x<<j<<k`等价于`(x<<j)<<k`。

向左移动只有一种情况，x向左移动k位，丢弃最高的k位，并在右端补k个0。

向右移动分为两种情况，逻辑右移和算术右移。逻辑右移在左边补k个0，得到$[0,\dots,0,x_{w-1},x_{w-2},\dots,x_k]$,算术右移在左边补k个最高有效位的值，得到$[x_{w-1},\dots,x_{w-1},x_{w-1},x_{w-2},\dots,x_{k}]$。

实际上，几乎所有的编译器机器组合都对有符号数使用算术右移。另一方面，对于无符号数，右移必须是逻辑的。

## 2.2 整数表示

### 2.2.1 整型数据类型

C语言支持多种整型数据类型来表示有限范围的整数。

每种类型可以用关键字来指定大小，当指示被表示的数字是非负数的时候声明为`unsigned`，默认为负数。

唯一一个与机器相关的取值范围是大小指示符`long`,大多数64位机器为8个字节，32位机器 为4个字节。

![img](./picture/2.2.1-1.PNG)

取值范围的不对称的，负数的范围比正数的范围大1。

C和C++都支持有符号（默认）和无符号数，Java只支持有符号数。

### 2.2.2 无符号数的编码

假设一个整数数据类型有$w$位，将位向量记作$\vec{x}$表示整个向量，或者是$[x_{w-1},x_{w-2},\dots,x_0]$表示向量中的每一位，把$\vec{x}$看成一个二进制表示的数，就有了$\vec{x}$的无符号表示。

函数$B2U_w$(Binary to Unsigned),表示把二进制转化为无符号数：

$B2U_w(\vec{x})=\sum\limits^{w-1}_{i=0}x_i2^i$

根据上式可以得到$UMax_w=\sum\limits_{i=0}^{w-1}2^i=2^w-1$

每一个介于$0\sim2^w-1$ 之间的数都有唯一一个$w$位的值编码。

$U2B_w$是其反函数。

### 2.2.3 补码编码

最常见有符号数的计算机表示方式就是补码(two’s-complement),这个定义中，字的最高有效位解释为负权，用函数$B2T_w$(Binary to Two’s-complement)来表示：

$B2T_w(\vec{x})=-x_{w-1}2^{w-1}+\sum\limits_{i=0}^{w-2}x_i2^i$

根据上式可以得到$TMin_w=-2^{w-1}$，$TMax_w=2^{w-1}-1$。

$B2T_w$是一个从长度为$w$的位模式到$TMin_w$和$TMax_w$之间数字的映射，同无符号表示一样，在可表示的取值范围内的每个数字都有一个唯一的$w$位的补码编码。

$T2B_w$使其反函数。

第一，补码的范围是不对称的，$|TMin|=|TMax|+1$,也就是说$TMin$没有与之对应的整数，之所以有这样的不对称性是因为，一半位模式表示负数，另一半表示非负数，而0是非负数，这就意味着能表示的整数比负数少一个。

第二，$UMax_w=2TMax_w+1$。补码表示中所有表示负数的位模式在无符号表示中都变成了正数。$-1$和$Umax$有同样的位模式，一个全为1的串。

### 2.2.4 有符号数和无符号数之间的转换

C语言允许在各种不同的数字数据类型之间做强制类型转换。

对于大多数C语言处理同样字长的有符号数和无符号数之间相互转换的一般规则是：数值可能会变，但是位模式不变。

补码转换为无符号数，对满足 $TMin \leq x \leq TMax$的$x$有：

$T2U_w(x)=\begin{cases}x+2^w,& x<0 \\x,&x\geq0 \end{cases}$

存在一个关系$B2U_w(\vec{x})-B2T_w(\vec{x})=2^wx_{w-1}$,得到$B2U_w(\vec{x})=B2T_w(\vec{x})+2^wx_{w-1}$

无符号数转化为补码，对满足$0 \leq x \leq UMax_w$的$x$有：

$U2T_w(x)=\begin{cases}x,&x\leq TMax_w \\x-2^w,&x>TMax_w\end{cases}$

对于上面两种转化来说：

![img](./picture/2.2.4-1.PNG)

函数$T2U$把负数转化成了大的整数，非负数则保持不变。

函数$U2T$对于小的数($\leq TMax_w$)，保持原值；对于大的数$(>TMax_w)$，数字将被转换为一个负数。

### 2.2.5 C语言中的有符号数与无符号数

大多数数字被认为是有符号的，当声明一个`123456`或者是`0x1A2B`这种常量的时候，被默认为有符号的，创建无符号常量需要在加后缀字符`u(U)`。

C语言允许无符号数和有符号数之间的转换，虽然C标准没有精确规定这种转换，大多数系统遵循位模式不变的原则。

C语言中出现了一些奇怪的行为：当执行一个运算的时候，如果它的一个运算符是有符号的而另一个是无符号的，那么有符号的参数会被隐式的转换为无符号数看，并假设这两个数是非负的来执行运算。尤其是存在$<,>$这种运算符时会出问题。

```c++
int main() {
	int a=-1;
	unsigned int b=0u;
	if(a<b) printf("YES");
	else printf("NO");
} //会输出NO,因为T2U(-1)=UMax
```

在C语言的头文件`limits.h`中

```c++
#define INT_MAX 2147483647
#define INT_MIN (-INT_MAX)-1
//由于编码的不对称性和C语言的转换规则
```

### 2.2.6 扩展一个数字的位表示

将一个无符号数转换为一个更大的数据类型，只要在表示前面加0。这种运算被称为零扩展。

无符号数的零扩展：

定义宽度为$w$的位向量$\vec{x}=[x_{w-1},x_{w-2},\dots,x_0]$和宽度为$w'$的位向量$x’=[0,\dots,0,x_{w-1},x_{w-2},\dots,x_0]$，其中$w'>w$,则$B2U_w(\vec{x})=B2U_{w'}(\vec{x'})$

将一个补码数字转换为一个更大的数据类型，执行一个符号扩展，在表示中添加最高有效位的值。

补码数的符号扩展：

定义宽度为$w$的位向量$\vec{x}=[x_{w-1},x_{w-2},\dots,x_0]$和宽度为$w'$的位向量$x’=[x_{w-1},\dots,x_{w-1},x_{w-1},x_{w-2},\dots,x_0]$，其中$w'>w$,则$B2U_w(\vec{x})=B2U_{w'}(\vec{x'})$。

证明$B2U_w(\vec{x})=B2U_{w'}(\vec{x'})$,根据归纳法，只需要证明$B2U_{w+1}(\vec{x})=B2U_{w}(\vec{x})$，二者做差即可证明。

事实上，从一个数据大小到另一个数据大小的转换，以及无符号和有符号数字之间的转换的相对顺序能够影响一个程序的行为。

把`short`转换为`unsigned`时，我们要先改变的大小，之后再完成有符号数到无符号数的转换。也就是说对于一个`short`类型的`x`， `(unsigned)x`等价于`(unsigned) (int)x`，而不是`(unsigned)(unsigned short)x`。这个规则是C语言标准要求的。

### 2.2.7 截断数字

截断无符号数

令$\vec{x}=[x_{w-1},x_{w-2},\dots,x_0]$，而$\vec{x'}$是将其截断为$k$位的结果：$\vec{x'}=[x_{k-1},x_{k-2},\dots,x_0]$。令$x=B2U_w(\vec{x}),x'=B2U_k(\vec{x'})$,则$x'=x \bmod 2^k$。证明定义即可。

截断补码数值：

令$\vec{x}=[x_{w-1},x_{w-2},\dots,x_0]$，而$\vec{x'}$是将其截断为$k$位的结果：$\vec{x'}=[x_{k-1},x_{k-2},\dots,x_0]$。令$x=B2U_w(\vec{x}),x'=B2T_k(\vec{x'})$,则$x'=U2T_k(x \bmod 2^k)$。

### 2.2.8 关于有符号数与无符号数的建议

有符号数到无符号数的隐式强制类型转换导致了某些非直观的行为。而这些非直观的特性经常导致程序错误，并且包含这种隐式强制类型转换很难被发现。

当把字仅仅看做是位的集合而没有任何数字意义时，无符号数值是非常有用的。

## 2.3 整数运算

### 2.3.1 无符号加法

定义运算$+^u_w$,表示无符号加法：

对于满足$0\leq x,y <2^w$的$x$和$y$有：

$x+^u_wy=\begin{cases}x+y,&x+y<2^w\\x+y-2^w,&2^w\leq x+y <2^{w+1}\end{cases}$

如果$x+y<2^w$,说明和的$w+1$位表示中最高位为0，截断不会改变这个数的值；如果$x+y\geq 2^w$，说明和的$w+1$位为1，阶段就相当于减去$2^w$。

执行C语言中，不会将溢出作为错误而发信号，有时候，我们可能希望判断是否发出了溢出。

对于$0 \leq x,y \leq UMax_w$,令$s=x+^u_wy$,发生溢出当且仅当$s<x$的时候，证明结合上式。

考虑$w$位的无符号数的集合，执行加法操作$+^u_w$,对于每个值$x$，必然有某个值$-^u_wx$,满足$-^u_wx+^u_wx=0$。

对于满足$0 \leq x < 2^w$的任意$x$，其$w$位的无符号逆元$-^u_wx$:

$-^u_wx=\begin{cases}0,&x=0\\2^w-x,&x>0\end{cases}$

### 2.3.2 补码加法

对于给定范围$-2^{w-1}\leq x,y \leq 2^{w-1}-1$的整数$x,y$,它们的和范围为$-2^w \leq x+y\leq 2^{w}-2$。

定义运算$x+^t_wy$为整数和$x+y$被截断为$w$位的结果：

$x+^t_wy=\begin{cases}x+y-2^w,&2^{w-1}\leq x+y\\x+y,&-2^{w-1}\leq x+y < 2^{w-1}\\x+y+2^w,&x+y<-2^{w-1}\end{cases}$

推导$x+^t_wy$: 

因为补码加法和无符号数加法有相同的位表示，所以把参数转换成无符号数进行无符号数加法，再转化成补码。

$x+^t_wy=U2T_w(T2U_w(x)+^u_wT2U_w(y))$

其中$T2U_w(x)=x+2^{w}x_{w-1}$,代入上式，

可得$x+^t_wy=U2T_w(x+2^{w}x_{w-1}+y+2^{w}y_{w-1} \mod 2^w)=U2T_w((x+y) \mod 2^w)$

<img src="./picture/2.3.2-1.PNG" alt="img" style="zoom: 80%;" />

检测补码加法中的溢出：

对满足$TMin\leq x,y \leq TMax$的$x,y$ 当且仅当$x,y>0$但$x+y<0$时，发生正溢出；当且仅当 $x,y<0$且$x+y>0$时，发生负溢出。

### 2.3.3 补码的非

在$TMin_w \leq x \leq Tmax_w$中的每个数字$x$都有$+^t_w$下的加法逆元。

补码的非$-^t_w$表示为：

$-^t_wx=\begin{cases}TMin_w,&x=TMin_w\\-x,&x>TMin_w\end{cases}$

### 2.3.4 无符号乘法 

范围在$0 \leq x,y \leq 2^w-1$的整数$x$,和$y$可以被表示为 $w$位的补码数字，乘积可能达到 $2w$位，C语言中的无符号乘法被定义为产生$w$位的值，就是$2w$中的低$w$位，记为$x*^u_wy$。

将一个无符号数截断为$w$ 位等价于该值模$2^w$。

对于满足$0 \leq x,y \leq UMax_w$的$x$和$y$有：

$x*^u_wy=(x·y)\mod 2^w$

### 2.3.5 补码乘法 

范围在$-2^{w-1}\leq x,y \leq 2^{w-1}-1$内的整数 $x$和$y$可以被表示为$w$位的补码数字，乘积可能达到$2w$位，C语言中的有符号乘法通过将$2w$位截断为 $w$位来实现，表示为 $x *^t_wy$。将一个补码数截断为$w$位，相当于先计算该值模$2^w$，再把无符号数转换为有符号数。

对于满足$TMin_w \leq x,y \leq TMax$的$x$和$y$有：

$x*^t_wy=U2T_w((x·y) \mod 2^w)$ ps:其中 $(x·y) \mod 2^w = (T2U_w(x)·T2U_w(y)) \mod 2^w$

对于无符号和补码的乘法来说，乘法运算的位级表示都是一样的，其中$T2B_w(x*^t_wy)=U2B_w(x*^u_wy)$。

### 2.3.6 乘以常数

在大多数机器上，整数乘法指令相当慢，需要10个或者更多的时钟周期，而其他整数运算（加法，减法，位级运算和移位）只需要1个时钟周期。因此，编译器试着用移位和加法运算的组合来代替乘以常数因子的乘法。

左移一个数值等价于执行一个与2的幂相乘的无符号乘法。

即使溢出的时候，通过移位得到的结果也是一样的。

假设一个程序包含表达式$x * 14$,编译器会将乘法重写为$(x<<3)+(x<<2)+(x<<1)$,还可以重写为$(x<<4)-(x<<1)$。

### 2.3.7 除以2的幂

大多数机器上，整数除法要比整数乘法更慢，需要30个甚至更多的时钟周期。

除以2的幂也是用移位操作，无符号数和补码分别使用逻辑移位和算术移位。

整数除法总是舍入到零，也就是会向下舍入一个正值，向上舍入一个负值。

无符号数的除法总是舍入到零，和整数除法一样。

补码的除法并不是这样，当表示正数的时候，补码的除法和无符号数的除法一样，是舍入到零。当表示负数的时候，补码的除法为向下舍入。我们通过在移位之前偏置这个值来修正这种不合适的舍入。

C变量$x$和$k$分别有补码值$x$和无符号数$k$,且$0 \leq k < w$,当执行算术移位的时候，$(x+(1<<k)-1)>>k$会产生$\left\lceil \frac{x}{2^w}\right\rceil$，实现向上舍入。

对于不需要舍入的情况，加上偏量只影响那些被移掉的位。对于需要舍入的情况，加上偏量导致较高的位加1。

偏置利用性质：对于整数 $x$和$y(y>0)$$\left\lceil \frac{x}{y}\right\rceil=\lfloor \frac{x+y-1}{y}\rfloor$

### 2.3.8 关于整数运算最后的思考

计算机执行的整数运算实际上是一种模运算形式，表示数字有限字长限制了可能的值的取值范围，结果可能溢出。补码提供了一种既能表示负数也能表示正数的灵活方法，同时使用了与执行无符号算术相同的位级实现。

C语言中`unsigned`类型可能会出现意想不到的错误。

## 2.4 浮点数

### 2.4.1 二进制小数

对二进制小数表示方法：$b=\sum\limits_{i=-n}^m2^ib_i$.

小数的二进制表示法只能表示形如$x\times2^y$的数，比如$\frac{1}{5}$就不能用二进制小数精确表示，但增加二进制小数的位数可以提高精度。

### 2.4.2 IEEE浮点数表示

IEEE浮点标准用$V=(-1)^s \times M \times 2^E$来表示一个数。

- 符号$s$，表示正负。
- 尾数$M$是一个二进制小数，它的范围是$1 \sim 2- \epsilon$或者是$0 \sim 1-\epsilon$
- 解码$E$的作用是对浮点数进行加权，$2^E$

浮点数的位表示划分为三个字段，`float`和`double`类型的划分位数也是不同的。

![img](./picture/2.4.2-1.PNG)

其中$exp$编码$E$,$frac$编码$M$。

根据$exp$的值，被编码的数分为三种情况（下图是单精度情况）

![img](./picture/2.4.2-2.PNG)

**情况1：规格化的值**

当$exp$的位不全为0且不全为1的时候，表示规格化的值。

阶码字段被解释为以偏置形式存在的有符号整数，$E=e-Bias$,其中$e$是无符号整数，位表示为$exp$，$Bias=2^{k-1}-1$。对于单精度来说是$-126 \sim +127$。

小数字段被解释为小数值$f$,其中$0 \leq f <1$,其二进制表示为$0.f_{n-1}f_{n-2}\dots f_0$。$M=1+f$。我们可以调整阶码$E$，使得$1 \leq M <2$,既然第一位总是1，我们可以舍弃，来获得额外的一位精度。

**情况2：非规格化的值**

当$exp$全为0的时候表示非规格化的值。其中$E=1-Bias,M=f$,不包含隐式的1。

非规格化的值有两个用途，提供了一种表示数值0的方式，但是存在$+0.0$和$-0.0$根据IEEE的浮点数格式，$+0.0$和$-0.0$在某些方面被认为是不同的，其他方面相同。另一个功能是表示非常接近$0.0$的数，提供了一种属性，称为逐渐下溢，可能的数值分布均匀的接近于$0.0$。

**情况3：特殊值**

当$exp$全为1的时候，表示特殊值。

当小数域全为0的时候，数值为$\infty$,根据$s$来区别$+\infty，-\infty$。当把两个很大的数相乘或者除以零的时候，可以用来表示溢出。

当小数域非0的时候，这个值被称为NaN(Not a Number),比如计算$\sqrt{-1}$或者$\infty-\infty$的时候，或者数据未初始化的时候。

### 2.4.3 数字示例 

![img](/picture/2.4.3-1.PNG)

可以观察到最大的非规格化数$\frac{7}{512}$和最小的规格化数$\frac{8}{512}$之间平滑的转变，这归功于对非规格化数E的定义为$1-Bias$。增大阶码的时候，就会得到更大的规格化的数，上图中最大的规格化值为240,超出之后就会被定义为$\infty$。

一个有趣的性质，当我们把上图中的位表达式解释为无符号整数的时候，它们就是按照升序排列的，就像他们表示的浮点数一样，IEEE如此设计就是可以用整数排序函数来进行排序的。

整数值12345(0x3039)和单精度浮点数12345.0(0x4640E400)在位级表示上有一段相同的编码，相关区域对应整数的低位，刚好在等于1的最高有效位之前停止（这个位就是隐藏的1），和浮点数表示的小数部分的高位是相匹配的。可以尝试把12345转化为单精度浮点数来理解这一过程。

### 2.4.4 舍入

舍入一般有四种方式：向偶数舍入，向零舍入，向下舍入，向上舍入。

为什么会存在向偶数舍入？

如果我们把两个可表示值得中间值向上舍入，那么平均值就会比正常的大，而向偶数舍入在大多数情况下避免了这种统计误差。

二进制小数也可以运用向偶数舍入法，考虑舍入值到最近的四分之一的位置（也就是小数点后两位），只有对$XX\dots X.X\dots XXY100\dots 0$才有效（其中Y为要被舍入的位置）。例如$10.00011_2(2\frac{2}{32})$向下舍入到$10.00_2(2)$，$10.00110_2$向上舍入到$10.01_2(2\frac{1}{4})$,因为这些值不是两个可能值的正中间值。我们将$10.11100_2(2\frac{7}{8})$舍入到$11.00_2(3)$,将$10.10100_2 2\frac{5}{8}$舍入到$10.10_2 (2\frac{1}{2})$,因为这些值都是两个可能值的中间值，并且我们倾向于使最低有效位为0。

### 2.4.5 浮点运算

浮点数加法：

我们将$x+^fy$定义为$round(x+y)$，对于所有的$x,y$这个运算是可交换的$x+^fy=y+^fx$,但是是不可结合的，比如$(3.14+1e10)-1e10=0$,而$3.14+(1e10-1e10)=3.14$。

对于任何$x$,都有$x+^fNaN=NaN$。

比如有下面代码:

```c++
x = a + b + c;
y = b + c + d;
//编译器可能通过下面的方式来减少一个浮点数加法
t = b + c;
x = a + t;
y = t + d;
```

对于x来说，可能产生不同的结果，因为浮点数加法不满足结合律，编译器偏向保守，避免任何对功能产生影响的优化。

浮点数乘法：

定义$x*^fy=round(x \times y)$,浮点数乘法是可交换的，但是不能结合和分配。

### 2.4.6 C语言中的浮点数

C语言提供了两种不同的浮点数类型，`float`和`double`,对应了单精度浮点和双精度浮点。

当int,float,double 之间进行强制类型转换的时候，原则如下：

- 从double转换为float,可能会溢出，精度也可能降低。

- 从float或者double转换为int，数值将会向零舍入。也可能会溢出，与Intel兼容的微处理器指定位模式$[1000\dots0]$（字长为$w$时的$TMin_w$）为整数不确定值。一个从浮点数到整数的转换，如果不能为该浮点数找到一个合理的整数近似值，就会产生这样一个数。

  因此`(int)1e10`会得到`-2147483648`。

  

