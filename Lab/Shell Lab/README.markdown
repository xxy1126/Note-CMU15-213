# Note

1. 一个发出而没有被接收的信号叫做待处理信号，任何时刻一种类型至多只会有一个待处理信号。如果一个进程有一个类型为k的待处理信号，那么任何接下来发送到这个进程的类型为k的信号都会被丢弃。

2. 一个进程可以有选择性的阻塞接收某种信号，当一种信号被阻塞的时候，它仍然可以被发送，但是产生的待处理信号不会被接收，直到进程取消队这钟信号的阻塞。

3. 进程组：默认的一个子程序和它的父亲同属于一个进程组。

4. 使用/bin/kill发送信号，pid为正时表示向一个进程发送信号，pid为负的时候表示向一个进程组发送pid。

5. 从键盘发送信号：在键盘上输入Ctrl+C会发送一个SIGINT信号到**前台进程组中的每个进程**。默认情况下是终止前台作业。类似的发送Ctrl+Z会发送SIGSTOP信号到前台进程组中的每个进程。默认情况下，结果是暂停（挂起）前台作业。

6. 用kill函数发送信号，如果pid大于0，发送信号给pid代表的进程；如果pid=0，则发送信号到调用进程所在的进程组；如果pid小于0，那么发送信号给|pid|代表的进程组。

7. 接收信号，当进程p从内核模式切换到用户模式的时候，会检查p进程的未被阻塞的待处理信号的集合，如果这个集合为空的话，内核将控制传递到p的逻辑控制流的下一条指令。如果这个集合非空，内核选择集合中的某个信号k，并且强制p接收信号k。

   每个信号都有一个默认的行为。

   > 进程终止，进程终止并转储内存，进程停止直到被SIGCONT信号重启，进程忽略信号

   使用signal可以修改和信号相关联的默认行为，SIGSTOP和SIGKILL默认没法改。

   当一个进程捕获了一个类型为k的信号时，会调用信号k设置的信号处理程序，允许一个处理函数捕获不同的信号。

   当信号处理程序执行return语句的时候，控制通常传递回控制流中进程被信号接收中断位置处的指令。

8. 信号处理程序可以被其他信号处理程序中断

9. linux提供阻塞信号的隐式和显式机制：

   > 隐式机制

   内核默认阻塞任何当前处理程序正在处理信号类型的待处理信号。

   > 显式机制

   可以使用sigprocmask函数和它的辅助函数，明确阻塞和解除阻塞选定的信号。

10. 安全编写信号处理

    编写信号处理程序，有几个问题

    1. 处理程序和主程序并发运行，共享同样的全局变量，因此可能与主程序和其他处理程序相互干扰
    2. 如何合适接收信号
    3. 不同的系统有不同的信号处理语义

    编写信号处理程序的时候，最好遵守的几个规定

    > G0. 处理程序尽可能简单

    > G1. 在处理程序中只调用异步信号安全的函数

    异步信号安全的函数能够被信号处理程序安全的调用，因为要么是可重入的（后面会学），要么不能被信号处理程序中断

    > G2. 保存恢复errno

    处理程序中调用errno可能会影响主程序中其他依赖于errno的部分

    > G3. 阻塞所有信号，保存对共享全局数据结构的访问

    在访问全局数据结构的时候阻塞所有信号保证了处理程序不会中断序列指令，要不然就有可能得到不可预知的结果。

    > G4. 用volatile声明全局变量

    用volatile来声明一个变量，告诉编译器不要缓存这个变量，避免了处理程序更改了全局变量但是main中读取的其实是寄存器中哪一个不变的值。调用全局变量的时候也应该阻塞所有的信号。

    > G5. 用sig_atomic_t 声明标志

    C语言提供一种整形数据类型sig_atomic_t，对它的读写保证是原子性（也就是不可中断的），可以用一条指令来实现他们。

11. 关于waitpid函数

` pid_t waitpid(pid_t pid, int *startup, int options);` 

通过调用waitpid来等待子进程终止或者停止。

默认情况下，options = 0 , waitpid挂起调用进程的执行，直到它的等待集合中的一个子进程终止。如果的等待集合中的一个进程在刚调用的时候就已经终止，那么waitpid就立即返回。在这两种情况中，waitpid返回导致waitpid返回的已终止子进程的PID。此时，已终止的子进程被回收，内核会从系统中删除掉它的所有痕迹。

（也就是当子程序exit之后，内核并不是立即把它从系统中清楚。相反，进程保持在一种已终止的状态中，直到被它的父进程回收）

12. 正确编写信号处理

未处理信号是不排队的，因为pending位向量中每种类型的信号只有一位，所以每种类型最多只能有一个未处理的信号。假如当前程序正在执行信号k的处理程序，信号k被阻塞，这时候如果有两个信号k到达程序，那么第二个就会被丢弃。

13. 同步流来避免讨厌的并发错误

    书上有一个称为竞争的经典同步错误示例，main函数中addjob和处理程序中deletejob存在竞争。

    子进程会继承父进程的被阻塞集合。

14. 显示地等待信号

    有时候主程序需要显式地等待某个信号处理程序运行，当linux shell创建一个前台作业地时候，在接受下一条用户命令之前，它必须等待作业终止，被SIGCHLD处理程序回收。
    
    可以采用sigsuspend函数，该函数是不可中断，可以保证避免潜在竞争的出现。
    
    sigsuspend函数暂时用mask替换当前的阻塞集合，然后挂起该进程，直到接收到一个信号，其行为要么是运行一个处理程序，要么是终止该进程。如果它的行为是终止，那么该进程不从sigsuspend返回就直接终止；如果它的行为是运行一个处理程序，那么sigsuspend从处理程序返回，然后恢复调用sigsuspend之前原有的阻塞集合。
    
15. 当一个子程序**暂停或者停止**的时候，内核会发送一个SIGCHLD信号给父进程。

# Lab Summary

这个实验主要是构建一个shell，关键在于进程和信号的控制

需要完成下面几个函数

eval，builtin_cmd, do_fgbg, waitfg, sigint_handler, sigstp_handler,sigchld_handler 

> eval函数

`eval`函数先判断是不是内置命令，也就是需要`builtin_cmd`来判断，如果是内置命令，就直接在`builtin_cmd`里运行了，如果不是的话，就需要新建一个进程在子进程里进行运行。

然后如果命令结尾有`&`符号的话，说明程序是在后台运行的，也就是shell不需要等待这个程序运行结束就可以读入下一个命令，也就是我们不需要waitfg。

需要注意的是，因为我们在后面发送信号的时候要发送给一个进程和它的子进程，那么我们就需要调用`setpgid(0,0)`来使新创建的子进程的进程组号和进程号一样，而不是和它的父亲的进程组号一样，如果不这样调用的话，那么我们发送信号的时候就会发送给shell程序本身。

> builtin_cmd

这个函数就是判断是不是内部命令就可以

> do_fgbg

这个函数的功能可以在`shell lab`说明文件中看到

`bg`命令要重新运行一个进程，发送一个`SIGCONT`信号给指定进程，`background`运行。

`fg`命令要重新运行一个进程，发送一个`SIGCONT`信号给指定进程，`foreground`运行。

> waitfg

这个函数等待子进程回收，用于shell等待运行`foreground`的程序结束，根据书中的我们可以采用`sigsuspend`函数。

> sigint_handler, sigstp_handler

这两个函数差不多，都是信号处理程序，停止当前`foreground`的进程，发送信号给这个进程。

> sigchld_handler

内核会向父进程发送`SIGCHLD`信号，当子进程停止或者终止的时候。所以我们需要判断是哪一种情况造成的子进程发送信号，还要判断是不是前台进程。

使用`waitpid(-1, &state, WNOHANG | WUNTRACE)` 可以立即返回，而不是挂起调用程序的执行。

最后就是信号的阻塞，要在合适的地方进行信号阻塞来避免竞争的错误。